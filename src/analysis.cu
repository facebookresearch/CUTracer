/*
 * SPDX-FileCopyrightText: Copyright (c) Meta Platforms, Inc. and affiliates.
 * SPDX-FileCopyrightText: Copyright (c) 2019 NVIDIA CORPORATION & AFFILIATES.
 * SPDX-License-Identifier: MIT AND BSD-3-Clause
 *
 * This source code contains modifications by Meta Platforms, Inc. licensed under MIT,
 * based on original NVIDIA nvbit sample code licensed under BSD-3-Clause.
 * See LICENSE file in the root directory for Meta's license terms.
 * See LICENSE-BSD file in the root directory for NVIDIA's license terms.
 */

#include <assert.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#include <map>
#include <string>
#include <unordered_map>
#include <unordered_set>

#include "analysis.h"
#include "common.h"
#include "cuda.h"
#include "env_config.h"
#include "log.h"
#include "utils/channel.hpp"

extern pthread_mutex_t mutex;
extern std::unordered_map<CUcontext, CTXstate *> ctx_state_map;
extern std::map<uint64_t, std::pair<CUcontext, CUfunction>> kernel_launch_to_func_map;
extern std::map<uint64_t, uint32_t> kernel_launch_to_iter_map;

/**
 * @brief Extracts the full instruction mnemonic from a SASS line.
 *
 * This function parses a SASS instruction string to extract the mnemonic,
 * which includes the base instruction and any dot-separated modifiers
 * (e.g., "IMAD.MOV.U32"). It correctly handles and skips optional
 * predicates (e.g., "@!P0").
 *
 * @param sass_line The full SASS instruction line.
 * @return The extracted instruction mnemonic as a string.
 */
std::string extract_instruction_name(const std::string &sass_line) {
  // SASS format examples:
  // CS2R.32 R7, SR_CLOCKLO ;
  // @!P0 IMAD.MOV.U32 R6, RZ, RZ, 0x800000 ;

  size_t start_pos = 0;

  // Skip whitespace
  while (start_pos < sass_line.length() && isspace(sass_line[start_pos])) {
    start_pos++;
  }

  // Skip predicate if present (starts with @)
  if (start_pos < sass_line.length() && sass_line[start_pos] == '@') {
    // Find the end of predicate part (next space)
    while (start_pos < sass_line.length() && !isspace(sass_line[start_pos])) {
      start_pos++;
    }
    // Skip whitespace after predicate
    while (start_pos < sass_line.length() && isspace(sass_line[start_pos])) {
      start_pos++;
    }
  }

  // Extract instruction name (until first space)
  size_t end_pos = start_pos;
  while (end_pos < sass_line.length() && !isspace(sass_line[end_pos])) {
    end_pos++;
  }

  if (start_pos >= sass_line.length() || end_pos <= start_pos) {
    return "UNKNOWN";
  }

  return sass_line.substr(start_pos, end_pos - start_pos);
}

/**
 * @brief Processes a single instruction packet for histogram analysis.
 *
 * This function is the core of the instruction histogram feature. It uses
 * special "clock" instructions (generated by `pl.scope`) as markers to define
 * regions of interest.
 *
 * The logic operates in a start/stop fashion:
 * - The first clock instruction encountered by a warp starts the collection.
 * - The second clock instruction stops the collection and saves the histogram for
 *   the completed region.
 * - The third starts a new region, the fourth stops it, and so on.
 *
 * @warning This start/stop model does not support nested `pl.scope` blocks.
 * A nested scope will be flattened into a single sequence of start/stop
 * markers, which may lead to unintended region definitions.
 *
 * @param ri Pointer to the received opcode data packet (`opcode_only_t`).
 * @param ctx_state Pointer to the state for the current CUDA context.
 * @param warp_states A map tracking the collection state of each warp.
 * @param completed_histograms A vector where histograms of completed regions are
 * stored.
 */
void process_instruction_histogram(const opcode_only_t *ri, CTXstate *ctx_state,
                                   std::unordered_map<int, WarpState> &warp_states,
                                   std::vector<RegionHistogram> &completed_histograms) {
  // Get current function from kernel launch ID to find the correct SASS maps.
  std::map<uint64_t, std::pair<CUcontext, CUfunction>>::iterator func_iter =
      kernel_launch_to_func_map.find(ri->kernel_launch_id);
  if (func_iter == kernel_launch_to_func_map.end()) {
    return;  // Unknown kernel, skip histogram processing
  }

  CUfunction current_func = func_iter->second.second;

  // Get clock opcode IDs for this function, which mark region boundaries.
  const std::unordered_set<int> *clock_opcode_ids = nullptr;
  if (ctx_state->clock_opcode_ids.count(current_func)) {
    clock_opcode_ids = &ctx_state->clock_opcode_ids.at(current_func);
  }

  // Get SASS mapping for this function
  const std::map<int, std::string> *sass_map_for_func = nullptr;
  if (ctx_state->id_to_sass_map.count(current_func)) {
    sass_map_for_func = &ctx_state->id_to_sass_map.at(current_func);
  }

  if (!clock_opcode_ids || !sass_map_for_func) {
    return;  // No SASS or clock instruction mapping available for this function.
  }

  int warp_id = ri->warp_id;
  WarpState &current_state = warp_states[warp_id];
  bool is_clock_instruction = clock_opcode_ids->count(ri->opcode_id) > 0;

  // This block implements the start/stop logic for regions.
  if (is_clock_instruction) {
    if (current_state.is_collecting) {
      // This is an "end" clock: the region is complete.
      if (!current_state.histogram.empty()) {
        // Save the completed histogram.
        completed_histograms.push_back({warp_id, current_state.region_counter, current_state.histogram});
        current_state.histogram.clear();
        current_state.region_counter++;
      }
      // Stop collecting until the next "start" clock is found.
      current_state.is_collecting = false;
    } else {
      // This is a "start" clock: begin collecting instructions.
      current_state.is_collecting = true;
    }
  }

  // If collection is active, record the current instruction.
  if (current_state.is_collecting && sass_map_for_func->count(ri->opcode_id)) {
    // Extract the base instruction name from the full SASS string.
    const std::string &sass_line = sass_map_for_func->at(ri->opcode_id);
    std::string instruction_name = extract_instruction_name(sass_line);
    current_state.histogram[instruction_name]++;
  }
}

/**
 * @brief Dumps the collected histograms for a completed kernel launch to a file.
 *
 * This function is called when a kernel boundary is detected (i.e., when a new
 * kernel_launch_id is seen). It collates all histograms from the *previous*
 * kernel launch and triggers the process to write them to a CSV file.
 *
 * @param kernel_launch_id The ID of the kernel launch that has just finished.
 * @param histograms A vector containing all the completed region histograms for
 * that kernel.
 */
void dump_previous_kernel_data(uint64_t kernel_launch_id, const std::vector<RegionHistogram> &histograms) {
  if (histograms.empty()) {
    return;  // Nothing to dump.
  }

  // Find kernel info from global mapping
  if (kernel_launch_to_func_map.find(kernel_launch_id) != kernel_launch_to_func_map.end()) {
    auto [ctx, func] = kernel_launch_to_func_map[kernel_launch_id];
    uint32_t iteration = kernel_launch_to_iter_map[kernel_launch_id];

    // Use existing CSV generation logic.
    dump_histograms_to_csv(ctx, func, iteration, histograms);

    // Clean up mapping tables to free memory for subsequent kernels.
    kernel_launch_to_func_map.erase(kernel_launch_id);
    kernel_launch_to_iter_map.erase(kernel_launch_id);
  }
}

/**
 * @brief Writes a set of histograms to a formatted CSV file.
 *
 * This function handles the file I/O for persisting the analysis results. It
 * creates a uniquely named CSV file for a given kernel launch and writes the
 * histogram data in a structured format.
 *
 * @param ctx The CUDA context of the kernel.
 * @param func The kernel function.
 * @param iteration The iteration number of the kernel launch.
 * @param histograms The histogram data to be written to the file.
 */
void dump_histograms_to_csv(CUcontext ctx, CUfunction func, uint32_t iteration,
                            const std::vector<RegionHistogram> &histograms) {
  if (histograms.empty()) {
    return;  // Nothing to dump.
  }

  std::string basename = generate_kernel_log_basename(ctx, func, iteration);
  std::string csv_filename = basename + "_hist.csv";

  FILE *fp = fopen(csv_filename.c_str(), "w");
  if (!fp) {
    oprintf("ERROR: Could not open histogram file %s\n", csv_filename.c_str());
    return;
  }

  // Header for the CSV file.
  fprintf(fp, "warp_id,region_id,instruction,count\n");
  // Iterate through each completed region and write its histogram data.
  for (const RegionHistogram &region_result : histograms) {
    for (const std::pair<const std::string, int> &pair : region_result.histogram) {
      const std::string &instruction_name = pair.first;
      int count = pair.second;
      fprintf(fp, "%d,%d,\"%s\",%d\n", region_result.warp_id, region_result.region_id, instruction_name.c_str(), count);
    }
  }
  fclose(fp);
  loprintf("Histogram data dumped to %s\n", csv_filename.c_str());
}

static uint64_t get_kernel_launch_id(const message_header_t* header) {
  switch (header->type) {
      case MSG_TYPE_REG_INFO:
          return ((const reg_info_t*)header)->kernel_launch_id;
      case MSG_TYPE_OPCODE_ONLY:
          return ((const opcode_only_t*)header)->kernel_launch_id;
      case MSG_TYPE_MEM_ACCESS:
          return ((const mem_access_t*)header)->kernel_launch_id;
      default:
          return 0; // Or some other invalid value
  }
}

/**
 * @brief The main thread function for receiving and processing data from the
 * GPU.
 *
 * This function is based on the `recv_thread_fun` from NVIDIA's `mem_trace`
 * example. It runs in a separate CPU thread for each CUDA context, continuously
 * receiving data packets from the GPU channel and processing them.
 *
 * Meta's enhancements transform this from a simple single-purpose function to a
 * versatile multi-analysis pipeline:
 *  - **Generic Message-Passing System**: The original function only handled one
 *    data type (`mem_access_t`). This version uses a `message_header_t` to
 *    identify different packet types (`reg_info_t`, `opcode_only_t`, etc.) and
 *    dispatch them to the appropriate analysis logic.
 *  - **Instruction Histogram Analysis**: It contains the complete host-side logic
 *    for the `PROTON_INSTR_HISTOGRAM` feature, including state management for
 *    each warp (`warp_states`) and tracking completed regions.
 *  - **Kernel Boundary Detection**: It introduces robust state management across
 *    kernel launches by tracking `kernel_launch_id`. This allows it to detect
 *    when a kernel has finished, ensuring that all pending data for that kernel
 *    is finalized and dumped before processing the next one.
 *  - **SASS String Enrichment**: For richer logging, it looks up the SASS string
 *    for a given `opcode_id` to provide more context in the trace output.
 *
 * @param args A void pointer to the `CUcontext` for which this thread is
 * launched.
 * @return void* Always returns NULL.
 */
void *recv_thread_fun(void *args) {
  CUcontext ctx = (CUcontext)args;

  pthread_mutex_lock(&mutex);
  /* get context state from map */
  assert(ctx_state_map.find(ctx) != ctx_state_map.end());
  CTXstate *ctx_state = ctx_state_map[ctx];

  ChannelHost *ch_host = &ctx_state->channel_host;
  pthread_mutex_unlock(&mutex);
  char *recv_buffer = (char *)malloc(CHANNEL_SIZE);

  // Per-thread, per-context state for histogram analysis.
  std::unordered_map<int, WarpState> warp_states;
  std::vector<RegionHistogram> local_completed_histograms;

  // Used to detect when a new kernel begins.
  uint64_t last_seen_kernel_launch_id = UINT64_MAX;  // Initial invalid value

  while (ctx_state->recv_thread_done == RecvThreadState::WORKING) {
    uint32_t num_recv_bytes = ch_host->recv(recv_buffer, CHANNEL_SIZE);

    if (num_recv_bytes > 0) {
      // Process data packets in this chunk

      uint32_t num_processed_bytes = 0;
      while (num_processed_bytes < num_recv_bytes) {
        // First read the message header to determine the message type
        message_header_t *header = (message_header_t *)&recv_buffer[num_processed_bytes];
        const char *sass_str = "N/A";

        
        uint64_t current_launch_id = get_kernel_launch_id(header);
        bool is_new_kernel = false;

        if (current_launch_id != 0 && current_launch_id != last_seen_kernel_launch_id) {
            is_new_kernel = true;
            if (last_seen_kernel_launch_id != UINT64_MAX) {
                // Cleanup for the previous kernel
                if (is_analysis_type_enabled(AnalysisType::PROTON_INSTR_HISTOGRAM)) {
                    // Dump any remaining histograms for warps that were collecting
                    for (auto &pair : warp_states) {
                      if (pair.second.is_collecting && !pair.second.histogram.empty()) {
                        local_completed_histograms.push_back(
                            {pair.first, pair.second.region_counter, pair.second.histogram});
                      }
                    }
                    dump_previous_kernel_data(last_seen_kernel_launch_id, local_completed_histograms);
                    local_completed_histograms.clear();
                    warp_states.clear();
                }
            }
            last_seen_kernel_launch_id = current_launch_id;
        }

        if (header->type == MSG_TYPE_REG_INFO) {
          reg_info_t *ri = (reg_info_t *)&recv_buffer[num_processed_bytes];
          // Get SASS string for trace output
          auto func_iter = kernel_launch_to_func_map.find(ri->kernel_launch_id);
          if (func_iter != kernel_launch_to_func_map.end()) {
            auto [f_ctx, f_func] = func_iter->second;
            if (ctx_state->id_to_sass_map.count(f_func) && ctx_state->id_to_sass_map[f_func].count(ri->opcode_id)) {
              sass_str = ctx_state->id_to_sass_map[f_func][ri->opcode_id].c_str();
            }
          }

          trace_lprintf("CTX %p - CTA %d,%d,%d - warp %d - %s:\n", ctx, ri->cta_id_x, ri->cta_id_y, ri->cta_id_z,
                        ri->warp_id, sass_str);

          // Print register values
          for (int reg_idx = 0; reg_idx < ri->num_regs; reg_idx++) {
            trace_lprintf("  * ");
            for (int i = 0; i < 32; i++) {
              trace_lprintf("Reg%d_T%02d: 0x%08x ", reg_idx, i, ri->reg_vals[i][reg_idx]);
            }
            trace_lprintf("\n");
          }
          trace_lprintf("\n");
          num_processed_bytes += sizeof(reg_info_t);

        } else if (header->type == MSG_TYPE_OPCODE_ONLY) {
          if (is_analysis_type_enabled(AnalysisType::PROTON_INSTR_HISTOGRAM)) {
            opcode_only_t *oi = (opcode_only_t *)&recv_buffer[num_processed_bytes];

            process_instruction_histogram(oi, ctx_state, warp_states, local_completed_histograms);
          }
          num_processed_bytes += sizeof(opcode_only_t);

        } else if (header->type == MSG_TYPE_MEM_ACCESS) {
          mem_access_t *mem = (mem_access_t *)&recv_buffer[num_processed_bytes];

          // Get SASS string for trace output.
          std::map<uint64_t, std::pair<CUcontext, CUfunction>>::iterator func_iter =
              kernel_launch_to_func_map.find(mem->kernel_launch_id);
          if (func_iter != kernel_launch_to_func_map.end()) {
            std::pair<CUcontext, CUfunction> kernel_info = func_iter->second;
            CUfunction f_func = kernel_info.second;
            if (ctx_state->id_to_sass_map.count(f_func) && ctx_state->id_to_sass_map[f_func].count(mem->opcode_id)) {
              sass_str = ctx_state->id_to_sass_map[f_func][mem->opcode_id].c_str();
            }
          }

          trace_lprintf(
              "CTX %p - kernel_launch_id %ld - CTA %d,%d,%d - warp %d - PC %ld - "
              "%s:\n",
              ctx, mem->kernel_launch_id, mem->cta_id_x, mem->cta_id_y, mem->cta_id_z, mem->warp_id, mem->pc, sass_str);
          trace_lprintf("  Memory Addresses:\n  * ");
          int printed = 0;
          for (int i = 0; i < 32; i++) {
            if (mem->addrs[i] != 0) {  // Only print non-zero addresses
              trace_lprintf("T%02d: 0x%016lx ", i, mem->addrs[i]);
              printed++;
              if (printed % 4 == 0 && i < 31) {
                trace_lprintf("\n    ");
              }
            }
          }
          trace_lprintf("\n\n");
          num_processed_bytes += sizeof(mem_access_t);
        } else {
          // Unknown message type, print error and break loop
          // TODO: handle error message in our current log mechanism
          fprintf(stderr,
                  "ERROR: Unknown message type %d received in recv_thread_fun. "
                  "Stopping processing of this chunk.\n",
                  header->type);
          continue;
        }
      }
    }
  }

  // Dump data for the very last kernel if it exists.
  if (last_seen_kernel_launch_id != UINT64_MAX) {
    // Dump any remaining histograms for warps that were still collecting.
    for (const std::pair<const int, WarpState> &pair : warp_states) {
      if (pair.second.is_collecting && !pair.second.histogram.empty()) {
        local_completed_histograms.push_back({pair.first, pair.second.region_counter, pair.second.histogram});
      }
    }
    if (!local_completed_histograms.empty()) {
      dump_previous_kernel_data(last_seen_kernel_launch_id, local_completed_histograms);
    }
  }

  free(recv_buffer);
  ctx_state->recv_thread_done = RecvThreadState::FINISHED;
  return NULL;
}
